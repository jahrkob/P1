import serial
import time
import csv
import numpy as np
from datetime import datetime
import os

class CPADataCollector:
    def __init__(self, port='COM3', baudrate=115200):
        self.port = port
        self.baudrate = baudrate
        self.ser = None
        self.trace_count = 0
        self.data_dir = "cpa_traces"
        
        # Create data directory
        if not os.path.exists(self.data_dir):
            os.makedirs(self.data_dir)
    
    def connect(self):
        """Connect to Arduino"""
        try:
            self.ser = serial.Serial(self.port, self.baudrate, timeout=2)
            time.sleep(2)  # Wait for Arduino to reset
            print(f"Connected to {self.port} at {self.baudrate} baud")
            
            # Read initial messages
            while self.ser.in_waiting:
                line = self.ser.readline().decode('utf-8', errors='ignore').strip()
                print(line)
            
            return True
        except Exception as e:
            print(f"Failed to connect: {e}")
            return False
    
    def collect_trace(self, trace_num, oscilloscope):
        """
        Collect one trace
        Args:
            trace_num: Trace number
            oscillscope: Oscilloscope object (if using automated scope control)
        """
        print(f"Collecting trace {trace_num}...")
        
        # Send command to Arduino to start new encryption
        # (Arduino is already running in loop, just wait for trigger)
        
        # Here you would trigger your oscilloscope and save the data
        # This depends on your oscilloscope model and connection
        
        # Example for manual collection:
        print(f"  1. Oscilloscope ready?")
        print(f"  2. Press Enter when ready to capture trace {trace_num}")
        input()
        
        # For Rigol DS1000Z series (example):
        # scope.query(':DIGitize CHANnel1')
        # data = scope.query(':WAV:DATA? CHAN1')
        
        # Save trace data
        # self.save_trace(trace_num, data)
        
        # Wait for Arduino to complete (TRACE_END message)
        if self.ser:
            while True:
                if self.ser.in_waiting:
                    line = self.ser.readline().decode('utf-8', errors='ignore').strip()
                    if "TRACE_END" in line:
                        break
        
        print(f"  Trace {trace_num} collected")
    
    def save_trace(self, trace_num, voltage_data, plaintext=None):
        """Save trace to CSV file"""
        filename = os.path.join(self.data_dir, f"trace_{trace_num:04d}.csv")
        
        with open(filename, 'w', newline='') as f:
            writer = csv.writer(f)
            writer.writerow(['Sample', 'Voltage'])
            
            for i, voltage in enumerate(voltage_data):
                writer.writerow([i, voltage])
        
        # Save plaintext if provided
        if plaintext:
            pt_filename = os.path.join(self.data_dir, f"plaintext_{trace_num:04d}.txt")
            with open(pt_filename, 'w') as f:
                f.write(plaintext.hex())
        
        print(f"  Saved to {filename}")
    
    def collect_batch(self, num_traces=100):
        """Collect a batch of traces"""
        print(f"\nCollecting {num_traces} traces...")
        print("=" * 50)
        
        start_time = time.time()
        
        for i in range(num_traces):
            self.collect_trace(i + 1, oscilloscope=None)  # Pass your scope object here
            
            # Progress update
            if (i + 1) % 10 == 0:
                elapsed = time.time() - start_time
                remaining = (elapsed / (i + 1)) * (num_traces - i - 1)
                print(f"\nProgress: {i + 1}/{num_traces}")
                print(f"Elapsed: {elapsed:.1f}s, Remaining: {remaining:.1f}s")
        
        total_time = time.time() - start_time
        print(f"\nCollection complete!")
        print(f"Total time: {total_time:.1f}s")
        print(f"Average time per trace: {total_time/num_traces:.2f}s")
    
    def create_metadata(self):
        """Create metadata file with collection info"""
        metadata = {
            'date': datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
            'key': '3b3898371520f75e',
            'algorithm': 'DES',
            'platform': 'Arduino',
            'sampling_rate': '70 MHz',
            'num_traces': self.trace_count
        }
        
        meta_file = os.path.join(self.data_dir, "metadata.txt")
        with open(meta_file, 'w') as f:
            for key, value in metadata.items():
                f.write(f"{key}: {value}\n")
    
    def close(self):
        """Close serial connection"""
        if self.ser:
            self.ser.close()
            print("Serial connection closed")

# Manual collection script
def manual_collection_guide():
    print("\n" + "="*60)
    print("MANUAL DATA COLLECTION GUIDE")
    print("="*60)
    
    print("\n1. SETUP:")
    print("   - Upload the modified Arduino code")
    print("   - Connect oscilloscope:")
    print("     * Channel 1: Power measurement (via resistor)")
    print("     * Channel 2: Trigger (Pin 2)")
    print("   - Configure oscilloscope:")
    print("     * Timebase: 5μs/div (adjust based on encryption time)")
    print("     * Sampling: 70 MS/s")
    print("     * Trigger: Rising edge on Channel 2")
    print("     * Record length: 2000-5000 samples")
    
    print("\n2. COLLECTION PROCEDURE:")
    print("   Step 1: Start Arduino")
    print("   Step 2: Configure oscilloscope")
    print("   Step 3: For each trace:")
    print("     a. Press oscilloscope SINGLE button")
    print("     b. Wait for trigger (LED blinks)")
    print("     c. Save trace as CSV")
    print("     d. Rename to trace_001.csv, trace_002.csv, etc.")
    
    print("\n3. PLAINTEXT RECORDING:")
    print("   - Open Arduino Serial Monitor (115200 baud)")
    print("   - Save plaintexts to file")
    print("   - Or use the Python script to automate")
    
    print("\n4. TARGET: Collect 100-500 traces")
    print("   - More traces = better results")
    print("   - Ensure traces are aligned (use trigger)")

# Quick test to verify setup
def quick_test():
    """Run a quick test to verify the setup works"""
    print("\nQuick Test Procedure:")
    print("1. Upload Arduino code")
    print("2. Open Serial Monitor (115200 baud)")
    print("3. You should see:")
    print("   - 'DES CPA Data Collection'")
    print("   - Random seed")
    print("   - 'Ready to collect traces...'")
    print("4. LED should blink with each encryption")
    print("5. Trigger pin should go HIGH during encryption")
    
    print("\nUse oscilloscope to verify:")
    print("- Trigger signal on Pin 2")
    print("- Power consumption changes during encryption")
    print("- Encryption takes ~400 cycles at 16MHz = ~25μs")

if __name__ == "__main__":
    # Create collector object
    collector = CPADataCollector(port='COM3')  # Change to your port
    
    # Connect to Arduino
    if collector.connect():
        # Run quick test
        quick_test()
        
        # Show manual guide
        manual_collection_guide()
        
        # Start collection (uncomment when ready)
        # collector.collect_batch(num_traces=100)
        
        collector.close()
    else:
        print("Please check your Arduino connection and port.")
        print("Common ports:")
        print("  Windows: COM3, COM4, COM5...")
        print("  Linux: /dev/ttyUSB0, /dev/ttyACM0")
        print("  Mac: /dev/cu.usbmodem...")